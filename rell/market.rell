enum status{
 	PASSIVE,
 	ON_SALE,
 	ON_AUCTION,
 	ON_TIMED_AUCTION
}

enum order_types{
	MINT,
	BUY,
	SELL,
	AUCTION,
	TIMED_AUCTION,
	BID,
	OFFER,
	UPDATE_SELL,
	CANCEL_SELL,
	CANCEL_AUCTION,
	CANCEL_BID,
	CANCEL_OFFER,
	ACCEPT_OFFER,
	END_AUCTION
}

entity user {
	key pubkey: pubkey;
	key username: text;
	mutable nickname;
	mutable profile_image: text;
	mutable bio: text;
	created_at: timestamp;
}

entity likes {
	key liker: user;
	key item: item;
	created_at: timestamp;
}

entity follows{
	key follower_user: user,followed_user: user;
	created_at: timestamp;
}



entity item{
 	name: text;
	description: text;
 	creator: user;
	mutable owner: user;
 	mutable item_status: status=status.value(PASSIVE);
 	mutable price: integer;
 	tokenURI: text;
	created_at: timestamp;
	mutable active_order: order;
	mutable active_bid: order=null;
 }

 entity order{
	index orderer: user,item: item,created_at: timestamp;
	type: order_types;
	deadline: timestamp=0;
	price: integer=0;
	minimum_bid_increase: integer=0;
	instant_buy_price: integer=0;
	cancelled: boolean=false;
 }

entity balance {
  	key user;
  	mutable amount: integer=0;
}


function latest_active_order_of_item_with_type(item: item,order_type: order_types){
		val latest_order=order@*{.item==selected_item,.cancelled==false,@sort_desc .created_at,.type==order_type} limit 1;
	return latest_order;
}





operation create_item(seller_pubkey: pubkey,name: text,_tokenURI: text,description: text){
	require( is_signer(seller_pubkey)) ;
	val seller=user@{seller_pubkey};
	val created_item=create item(name=name,creator=seller,owner=seller,item_status=status.value("PASSIVE"),tokenURI=_tokenURI,created_at=block.timestamp,active_order=null,description=description);
	val mint_order=create order(orderer=seller,item=created_item,created_at=block.timestamp,type=order_types.value("MINT"));
	update created_item(active_order=mint_order);
}

operation sell_item(seller_pubkey: pubkey, sale_price: integer, item_id: rowid){
	require( is_signer(seller_pubkey));

	val seller=user@{seller_pubkey};

 	val selected_item= item@{.rowid==item_id,.owner.pubkey==seller_pubkey};

	create order(orderer=seller,item=selected_item,type=order_types.value("SELL"),created_at=block.timestamp);,

 	update selected_item (item_status=status.value("ON_SALE"),price=sale_price);

}




operation register_user(user_pubkey: pubkey,name: text,nickname: text,profile_image: text,bio: text){
	require( is_signer(buyer_pubkey),"You are not the signer") ;
  	val new_user=create user (pubkey=user_pubkey,username=name,nickname=nickname,profile_image=profile_image,bio=bio);
  	create balance (new_user, 1000000);
}


operation buy(buyer_pubkey: pubkey, item_id: rowid) {
 	require( is_signer(buyer_pubkey),"You are not the signer") ;
	
	val buyer=user@{buyer_pubkey};
 	val selected_item=item@{.rowid==item_id};
  
 	require( selected_item.owner!=buyer,"You can't buy your own item");
 	require( balance@{buyer}.amount >= selected_item.price, "Insufficient balance" );
	require( selected_item.item_status==status.value("ON_SALE"),"Item is not on sale");
  
	val buy_order=create order(orderer=buyer,item=selected_item,type=order_types.value("BUY"),created_at=block.timestamp,price=selected_item.price);

 	update balance@{buyer} (amount-=selected_item.price);
 	update balance@{selected_item.owner} (amount+=selected_item.price);
	update selected_item(owner=buyer,status=status.value("PASSIVE"),price=0,active_order=buy_order);
  
 }

 operation instant_buy(buyer_pubkey: pubkey, item_id: rowid){
	require( is_signer(buyer_pubkey),"You are not the signer") ;
	
	val buyer=user@{buyer_pubkey};
 	val selected_item=item@{.rowid==item_id};
  
 	require( selected_item.owner!=buyer,"You can't buy your own item");
 	require( balance@{buyer}.amount >= selected_item.price, "Insufficient balance" );
	require( selected_item.item_status==status.value("ON_SALE"),"Item is not on sale");
  
	val buy_order=create order(orderer=buyer,item=selected_item,type=order_types.value("BUY"),created_at=block.timestamp,price=selected_item.price);

 	update balance@{buyer} (amount-=selected_item.price);
 	update balance@{selected_item.owner} (amount+=selected_item.price);
	update selected_item(owner=buyer,status=status.value("PASSIVE"),price=0,active_order=buy_order);
 }


operation create_auction(seller_pubkey: pubkey,item_id: rowid,price: integer,minimum_bid_increase: integer,instant_buy_price: integer){
	require( is_signer(seller_pubkey),"You are not the signer");

	val seller=user@{seller_pubkey};
 	val selected_item=item@{.rowid==item_id};
	require(selected_item.item_status==status.value("PASSIVE"), "Item is on sale already");

	val auction_order=create order(orderer=seller,item=selected_item,type=order_types.value("AUCTION"),created_at=block.timestamp,price=price,minimum_bid_increase=minimum_bid_increase,instant_buy_price=instant_buy_price);
	
	update selected_item(item_status=status.value("ON_AUCTION"),price=price,active_order=auction_order);
} 
operation create_timed_auction(seller_pubkey: pubkey,item_id: rowid,price: integer,minimum_bid_increase: integer,instant_buy_price: integer,deadline: timestamp){
	require( is_signer(seller_pubkey),"You are not the signer");

	val seller=user@{seller_pubkey};
 	val selected_item=item@{.rowid==item_id};
	require(selected_item.item_status==status.value("PASSIVE"),  "Item is on sale already");

	val timed_auction_order=create order(orderer=seller,item=selected_item,type=order_types.value("TIMED_AUCTION"),created_at=block.timestamp,price=price,minimum_bid_increase=minimum_bid_increase,instant_buy_price=instant_buy_price,deadline=deadline);
	
	update selected_item(item_status=status.value("ON_TIMED_AUCTION") ,price=price ,active_order=timed_auction_order);
} 

operation bid(bidder_pubkey: pubkey,item_id: rowid,bid_price: integer){
	require( is_signer(bidder_pubkey),"You are not the signer");

	val bidder=user@{bidder_pubkey};

	val selected_item=item@{.rowid==item_id};
	require(selected_item.item_status==status.value("ON_AUCTION"), "Item is not on an auction");

	val latest_order=latest_active_order_of_item_with_type(selected_item,order_types.value("AUCTION");
	val minBid=selected_item.price*(100+latest_order.minimum_bid_increase)/100;

	require(bid_price>=minBid,"You should bid higher");
 	
	// We look if the bidder bidded earlier to the same auction
	val old_bid_of_user=order@?{.orderer=bidder,.item==selected_item,.cancelled==false,.created_at>latest_order.created_at,.type==order_types.value("BID")};
	// I could make it not require to cancel but I could do it automatically here and give the amount immediately, but unfortunately I don't have the time for creating ui features like bid higher modal.
	require(empty(old_bid_of_user),"You have already bidded, cancel it to bid again");
	require( balance@{bidder}.amount >= minBid, "Insufficient balance" );

	val bid_order=create order(orderer=bidder,item=selected_item,type=order_types.value("BID"),created_at=block.timestamp,price=bid_price);
	
	update selected_item(price=bid_price,active_bid=bid_order);
 	update balance@{bidder} (amount-=bid_price);
	
}

operation offer(offerer_pubkey: pubkey,item_id: rowid,offer_price: integer){
	require( is_signer(offerer_pubkey),"You are not the signer");
	val offerer=user@{offerer_pubkey};
	val selected_item=item@{.rowid==item_id};

	require( balance@{bidder}.amount >= offer_price, "Insufficient balance" );
 	update balance@{offerer} (amount-=offer_price);

	create order(orderer=offerer,item=selected_item,type=order_types.value("OFFER"),price=offer_price,created_at=block.timestamp);

}

operation cancel_order(orderer_pubkey: pubkey,order_id: rowid){
	require( is_signer(orderer_pubkey),"You are not the signer");
	val orderer=user@{orderer_pubkey};
	val selected_order=order@{.rowid==order_id};

	require(selected_order.orderer==orderer,"You are not the orderer of the order");	
	require(selected_order.type==order_types.value("SELL") or order_types.value("BID") or order_types.value("OFFER"),"Can't cancel selected order type");
	require(selected_order.cancelled!=true,"Order already cancelled");

	update selected_order(cancelled=true);
	val item_of_order=selected_order.item;
	if(selected_order.type==order_types.value("SELL")){
		require(item_of_order.item_status==status.value("ON_SALE"),"Item not on sale");
	 	update selected_order(cancelled=true);		
		val cancel_order=create order(orderer=orderer,type=order_types.value("CANCEL_SALE"),item=item_of_order,created_at=block.timestamp);
		update item_of_order(item_status=status.value("PASSIVE"),active_order=cancel_order);
	}
	else if(selected_order.type==order_types.value("BID")){
		require(item_of_order.item_status==status.value("ON_AUCTION") or status.value("ON_TIMED_AUCTION"));
		update selected_order(cancelled=true);
		val latest_bid=latest_active_order_of_item_with_type(item_of_order,order_types.value("BID");

		if(latest_bid.created_at<selected_order.created_at){
			update item_of_order(price=latest_bid.price,active_bid=latest_bid);
		}
		val cancel_order=create order(orderer=orderer,type=order_types.value("CANCEL_BID"),item=item_of_order,created_at=block.timestamp);

		update balance@{user==orderer}(.amount+=selected_order.price);	
	}
	else(selected_order.type==order_types.value("OFFER")){
		update selected_order(cancelled=true);
		update balance@{user==orderer}(.amount+=selected_order.price);	
		val cancel_order=create order(orderer=orderer,type=order_types.value("CANCEL_OFFER"),item=item_of_order,created_at=block.timestamp);
	}
}

operation accept_offer(offer_id: rowid,accepter_pubkey: pubkey){
	require( is_signer(accepter_pubkey),"You are not the signer");

	val accepter=user@{accepter_pubkey};
	val selected_order=offer@{.rowid==offer_id,.type==order_types.value("OFFER")};
	val selected_item=selected_order.item;

	require(selected_item.owner==accepter,"You are not the owner of item");
	require(selected_order.cancelled==false,"This offer is cancelled");
	require(selected_item.status==status.value("PASSIVE") or status.value("ON_SALE"));

	val accept_offer_order= create order(orderer=accepter,item=selected_order.item,type=order_types.value("ACCEPT_OFFER"),created_at=block.timestamp,price=selected_order.price);

	update selected_item(owner=selected_order.orderer,status=status.value("PASSIVE"),price=0,active_order=accept_offer_order);
	update balance@{user==accepter}(.amount+=selected_order.price);
}

operation end_auction(bid_id: rowid,accepter_pubkey: pubkey){
	require( is_signer(accepter_pubkey),"You are not the signer");
	val accepter=user@{accepter_pubkey};
	val selected_order=order@{.rowid==offer_id,.type==order_types.value("BID")};
	val selected_item=selected_order.item;
	val auction_order=selected_item.active_order;

	require(selected_item.owner==accepter,"You are not the owner of item");
	require(selected_order.cancelled==false,"This bid is cancelled");
	require(selected_item.status==status.value("AUCTION") or status.value("TIMED_AUCTION"),"The item is not on an auction");

	val accept_offer_order= create order(orderer=accepter,item=selected_item,type=order_types.value("END_AUCTION"),created_at=block.timestamp,price=selected_order.price);
	update selected_item(owner=selected_order.orderer,status=status.value("PASSIVE"),price=0,active_order=accept_offer_order);
	update balance@{user==accepter}(.amount+=selected_order.price);
	val left_bids=order@*{.item==selected_item,.cancelled==false,.created_at>=auction_order.created_at,.type==order_types.value("BID"),.rowid!=selected_order.rowid};

	for(bid in left_bids) //Refunding left bids
	{
		if(bid.cancelled==false) //A little bit waste if block but I don't trust the loop to be consistent rn 
		{
			val bidder=bid.orderer;
	 		update balance@{user==bidder}(.amount+=bid.price);
	 		update bid(cancelled=true);
		}
	}
}

operation follow_or_unfollow(target_user: pubkey,follower_user: pubkey){
	val target=user@{target_user};
	val follower=user@{follower_user};
	val follow_record=follows@?{follower_user==follower,followed_user=target};
	if(empty(follow_record)){
		create follows(follower_user=follower,followed_user=target,created_at=block.timestamp);
	}
	else{
		delete follow_record;
	}
}

operation like_or_unlike(target_item: rowid,liker_user: pubkey){
	val target=item@{.rowid==target_item};
	val liker=user@{liker_user};
	val like_record=likes@?{liker==liker,item==target};
	if(empty(like_record)){
		create likes(liker=liker,item=target,created_at=block.timestamp);
	}
	else{
		delete like_record;
	}
}




 query get_items_on_sale(){ 
 
    return item@*{.on_sale==true}(id=.rowid,name=.name,creator=.creator.pubkey,owner=.owner.pubkey,price=.price,tokenURI=.tokenURI);

}
 query get_all_items() {
 
    return item@*{}(id=.rowid,name=.name,creator=.creator.pubkey,owner=.owner.pubkey,item_status=.item_status,price=.price,tokenURI=.tokenURI);
 }

 query get_item(item_id: rowid){ 
    return item@?{.rowid==item_id}(id=.rowid,name=.name,creator=.creator.pubkey,owner=.owner.pubkey,item_status=.item_status,price=.price,tokenURI=.tokenURI);
 }
 
 query get_items_by_owner(owner_pubkey: pubkey){
	return item@*{.owner==user@{owner_pubkey}}(id=.rowid,name=.name,creator=.creator.pubkey,owner=.owner.pubkey,item_status=.item_status,price=.price,tokenURI=.tokenURI);
 }
 
 query get_orders_of_item(item_id: rowid){
	return order@*{.item.rowid==item_id}(id=.rowid,orderer=.orderer,item=.item,type=.type,deadline=.deadline,minimum_bid_increase_percent=.minimum_bid_increase,instant_buy_price=.instant_buy_price,created_at=.created_at,price=.price);
 }

 query get_orders_of_orderer(orderer_pubkey: pubkey){
	return order@*{.orderer.pubkey==orderer_pubkey,@sort_desc .created_at}(id=.rowid,orderer=.orderer,item=.item,created_at=.created_at,price=.price);
 }

 query get_bids_of_item(item_id: rowid){
	return order@*{.item.rowid==item_id,type==order_types.value("BID")}(id=.rowid,orderer=.orderer,item=.item,price=.price,created_at=.created_at);
 }
 
 query get_followers_of_user(user_pubkey: pubkey){
	return follows@*{.followed_user==user@{user_pubkey},@sort_desc .created_at}(follower_user=.follower_user,followed_user=.followed_user,created_at=.created_at);
 }

 query get_follower_count_of_user(user_pubkey: pubkey){
	return follows@*{.followed_user==user@{user_pubkey},@sort_desc .created_at}.size();
 }
 
 query get_all_items_and_likes(){
	 return (i=item,l=likes)@*{l.item==i}(item_id=i.rowid,name=i.name,creator=i.creator,owner=i.owner,item_status=i.item_status,price=i.price,like_count=likes@*{.item==i}.size(),created_at=.created_at,tokenURI=.tokenURI);
 }

 
 query get_user_by_pubkey(user_pubkey: pubkey){
    return user@{user_pubkey}(pubKey=.pubkey,username=.username);
 }
 
 query get_balance_by_pubkey(user_pubkey : pubkey){
    return balance@{.user.pubkey==user_pubkey}(user=.user.pubkey,balance=.amount);
 }

 
 